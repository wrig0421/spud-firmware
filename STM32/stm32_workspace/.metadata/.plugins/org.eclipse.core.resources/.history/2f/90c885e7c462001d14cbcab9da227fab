#include "main.h"
#include "cmsis_os.h"
#include "FreeRTOS.h"
#include "task_dma_transfer.h"


extern TIM_HandleTypeDef g_tim1_handle;
extern TIM_HandleTypeDef g_tim15_handle;
extern TIM_HandleTypeDef g_tim16_handle;


void task_dma_transfer(void *argument)
{
    uint32_t dma_transfer = 0;

    while (1)
    {
        xTaskNotifyWait(0, dma_transfer, &dma_transfer, portMAX_DELAY);

        // TIM_CHANNEL_2 is the channel enabled for FLYN SIGN
        HAL_TIM_PWM_Start_DMA(&g_tim1_handle, TIM_CHANNEL_2, (uint32_t *)gp_pwm_data_fill, (strip_size * BITS_PER_BYTE * sizeof(ws2812b_led_t)) + WS2812B_RESET_TIME_CYCLES);
        datasentflag = 0;
        while (!datasentflag) osDelay(1);
        datasentflag = 0;

        HAL_TIM_PWM_Start_DMA(&g_tim15_handle, TIM_CHANNEL_1, (uint32_t *)gp_pwm_data_fill, (strip_size * BITS_PER_BYTE * sizeof(ws2812b_led_t)) + WS2812B_RESET_TIME_CYCLES);
        datasentflag = 0;
        while (!datasentflag) osDelay(1);
        datasentflag = 0;

        HAL_TIM_PWM_Start_DMA(&g_tim1_handle, TIM_CHANNEL_1, (uint32_t *)gp_pwm_data_fill, (strip_size * BITS_PER_BYTE * sizeof(ws2812b_led_t)) + WS2812B_RESET_TIME_CYCLES);
        datasentflag = 0;
        while (!datasentflag) osDelay(1);
        datasentflag = 0;

        // TIM 16 channel 1 does nothing...
        HAL_TIM_PWM_Start_DMA(&g_tim16_handle, TIM_CHANNEL_1, (uint32_t *)gp_pwm_data_fill, (strip_size * BITS_PER_BYTE * sizeof(ws2812b_led_t)) + WS2812B_RESET_TIME_CYCLES);
        datasentflag = 0;
        while (!datasentflag) osDelay(1);
        datasentflag = 0;

        //  HAL_TIM_PWM_Start_DMA(&g_tim1_handle, TIM_CHANNEL_3, (uint32_t *)gp_pwm_data_fill, (strip_size * BITS_PER_BYTE * sizeof(ws2812b_led_t)) + WS2812B_RESET_TIME_CYCLES);
        //  datasentflag = 0;
        //  while (!datasentflag);//{HAL_Delay(1);};
        //  datasentflag = 0;
    }
}
