#include <string.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include "stm32l4xx_hal.h"
#include "version.h"
#include "flash_info.h"

#define FLASH_INFO_DEFAULT_IMAGE_SLOT   FLASH_INFO_IMAGE_SLOT_1
#define FLASH_INFO_MINI_MAIN_SLOT       FLASH_INFO_MINI_MAIN_SLOT

#pragma pack(1)

typedef union
{
    uint32_t data[3];
} uint96_t;


// config
typedef uint8_t num_strips_t;

// image
typedef uint8_t valid_image_t;
typedef uint8_t selected_image_t;

typedef union
{
    version_date_and_time_t fw_version_date;
    uint8_t                 flat_data_uint8[sizeof(flash_info_fw_version_date_t)];
} flash_info_fw_version_t;

typedef uint8_t ;



typedef union
{
    struct
    {
        num_strips_t num_strips;
    } config_data;
    uint8_t                     flat_data_uint8[FLASH_INFO_SUB_BLOCK_SIZE_BYTES];
    uint16_t                    flat_data_uint16[FLASH_INFO_SUB_BLOCK_SIZE_BYTES / sizeof(uint16_t)];
    uint32_t                    flat_data_uint32[FLASH_INFO_SUB_BLOCK_SIZE_BYTES / sizeof(uint32_t)];
} flash_info_config_block_t;


typedef union
{
    struct
    {
        uint96_t uuid;
    } status_data;
    uint8_t                     flat_data_uint8[FLASH_INFO_SUB_BLOCK_SIZE_BYTES];
    uint16_t                    flat_data_uint16[FLASH_INFO_SUB_BLOCK_SIZE_BYTES / sizeof(uint16_t)];
    uint32_t                    flat_data_uint32[FLASH_INFO_SUB_BLOCK_SIZE_BYTES / sizeof(uint32_t)];
} flash_info_status_block_t;


typedef union
{
    struct
    {
        flash_info_image_slot_t active_image;
        version_date_and_time_t active_image_fw_version;
        flash_info_image_slot_t mini_main_image;
        version_date_and_time_t mini_main_image_fw_version;

        valid_image_t           valid_image;
        selected_image_t        selected_image;
    } image_data;
    uint8_t                     flat_data_uint8[FLASH_INFO_SUB_BLOCK_SIZE_BYTES];
    uint16_t                    flat_data_uint16[FLASH_INFO_SUB_BLOCK_SIZE_BYTES / sizeof(uint16_t)];
    uint32_t                    flat_data_uint32[FLASH_INFO_SUB_BLOCK_SIZE_BYTES / sizeof(uint32_t)];
} flash_info_image_block_t;
#pragma pack(0)


flash_info_status_block_t   g_flash_info_status_block;
flash_info_config_block_t   g_flash_info_config_block;
flash_info_image_block_t    g_flash_info_image_block;


void flash_info_status_init(void)
{
    g_flash_info_status_block.status_data.uuid[0] = HAL_GetUIDw0();
    g_flash_info_status_block.status_data.uuid[1] = HAL_GetUIDw1();
    g_flash_info_status_block.status_data.uuid[2] = HAL_GetUIDw2();
}


void flash_info_config_init(void)
{
    g_flash_info_config_block.config_data.num_strips = 1;
}


void flash_info_image_init(void)
{
    g_flash_info_image_block.image_data.active_image = FLASH_INFO_IMAGE_SLOT_1;
    //g_flash_info_image_block.image_data.active_image_fw_version = ;
    g_flash_info_image_block.image_data.mini_main_image = FLASH_INFO_MINI_MAIN_SLOT;
//    g_flash_info_image_block.image_data.mini_main_image_fw_version = ;
    g_flash_info_image_block.image_data.selected_image = FLASH_INFO_IMAGE_SLOT_1;
    g_flash_info_image_block.image_data.valid_image = UINT8_MAX;
}


void flash_info_init(void)
{
    flash_access_read_sub_block(FLASH_INFO_SUB_BLOCK_STATUS, g_flash_info_status_block.flat_data_uint32);
    flash_access_read_sub_block(FLASH_INFO_SUB_BLOCK_CONFIG, g_flash_info_config_block.flat_data_uint32);
    flash_access_read_sub_block(FLASH_INFO_SUB_BLOCK_IMAGE, g_flash_info_image_block.flat_data_uint32);
    if ((UINT32_MAX == g_flash_info_status_block.status_data.uuid[0]) &&
                    (UINT32_MAX == g_flash_info_status_block.status_data.uuid[1]) &&
                    (UINT32_MAX == g_flash_info_status_block.status_data.uuid[2]))
    {
        flash_info_status_init();
        flash_info_config_init();
        flash_info_image_init();
    }
    flash_info_firmware_version();
}


void flash_info_firmware_version(void)
{
    version_date_and_time_t version_date_time = \
    {
        .year = BUILD_DATE_YEAR,
        .month = BUILD_DATE_MONTH,
        .day = BUILD_DATE_DAY,
        .hour = BUILD_TIME_HOUR,
        .minutes = BUILD_TIME_MINUTE,
        .seconds = BUILD_TIME_SECOND,
        .fill = 0xFF
    };
    if (0 != memcmp((void *)&version_date_time,
                    (void *)(&g_flash_info_image_block.image_data.active_image_fw_version),
                    sizeof(version_date_and_time_t)))
    {
        memcpy((void *)(&g_flash_info_image_block.image_data.active_image_fw_version),
                        (void *)&version_date_time,
                        sizeof(version_date_and_time_t));
        // NEED TO WRITE THIS TO FLASH
    }

}


void flash_info_read_unique_id(uint32_t *uuid)
{
    uuid[0] = HAL_GetUIDw0();
    uuid[1] = HAL_GetUIDw1();
    uuid[2] = HAL_GetUIDw2();
}


void flash_info_write_image_block_to_flash(void *p_data, uint16_t address)
{
    bool write_to_flash = false;
    switch (address)
    {
        case offsetof(flash_info_image_block_t, image_data.active_image):
            if (0 != memcmp(&g_flash_info_image_block.image_data.active_image, p_data, sizeof(flash_info_image_slot_t)))
            {
                write_to_flash = true;
                memcpy(&g_flash_info_image_block.image_data.active_image, p_data, sizeof(flash_info_image_slot_t));
            }
        break;
        case offsetof(flash_info_image_block_t, image_data.active_image_fw_version):
            if (0 != memcmp(&g_flash_info_image_block.image_data.active_image_fw_version, p_data, sizeof(version_date_and_time_t)))
            {
                write_to_flash = true;
                memcpy(&g_flash_info_image_block.image_data.active_image_fw_version, p_data, sizeof(version_date_and_time_t));
            }
        break;
        case offsetof(flash_info_image_block_t, image_data.mini_main_image):
            if (0 != memcmp(&g_flash_info_image_block.image_data.mini_main_image, p_data, sizeof(flash_info_image_slot_t)))
            {
                memcpy(&g_flash_info_image_block.image_data.mini_main_image, p_data, sizeof(flash_info_image_slot_t));
            }
        break;
        case offsetof(flash_info_image_block_t, image_data.mini_main_image_fw_version):
            if (0 != memcmp(&g_flash_info_image_block.image_data.mini_main_image_fw_version, p_data, sizeof(version_date_and_time_t)))
            {
                memcpy(&g_flash_info_image_block.image_data.mini_main_image_fw_version, p_data, sizeof(version_date_and_time_t));
            }
        break;
        case offsetof(flash_info_image_block_t, image_data.valid_image):
            if (0 != memcmp(&g_flash_info_image_block.image_data.valid_image, p_data, sizeof(flash_info_image_slot_t)))
            {
                memcpy(&g_flash_info_image_block.image_data.valid_image, p_data, sizeof(flash_info_image_slot_t));
            }
        break;
        case offsetof(flash_info_image_block_t, image_data.selected_image):
            if (0 != memcmp(&g_flash_info_image_block.image_data.selected_image, p_data, sizeof(image_data.selected_image)))
            {
                memcpy(&g_flash_info_image_block.image_data.selected_image, p_data, sizeof(image_data.selected_image));
            }
        break;
        default:
        break;
    }
}


void flash_info_write_status_block_to_flash(uint16_t address)
{
    switch (address)
    {
        case offsetof(flash_info_config_block_t, config_data.num_strips):
        break;
        default:
        break;
    }
}


void flash_info_write_config_block_to_flash(uint16_t address)
{
    switch (address)
    {
        case offsetof(flash_info_config_block_t, config_data.num_strips):
        break;
        default:
        break;
    }
}



void flash_info_write_to_flash(flash_info_sub_block_t sub_block)
{
    switch (sub_block)
    {
        case FLASH_INFO_SUB_BLOCK_CONFIG:
            flash_info_write_config_block_to_flash(address);
        break;
        case FLASH_INFO_SUB_BLOCK_STATUS:
            flash_info_write_status_block_to_flash(address);
        break;
        case FLASH_INFO_SUB_BLOCK_IMAGE:
            flash_info_write_image_block_to_flash(address);
        break;
        default:
        break;
    }
}


void flash_info_read_from_flash(flash_info_sub_block_t sub_block, uint16_t address)
{
    switch (sub_block)
    {
        case FLASH_INFO_SUB_BLOCK_CONFIG:
            flash_info_read_config_block_to_flash(address);
        break;
        case FLASH_INFO_SUB_BLOCK_STATUS:
            flash_info_read_status_block_to_flash(address);
        break;
        case FLASH_INFO_SUB_BLOCK_IMAGE:
            flash_info_read_image_block_to_flash(address);
        break;
        default:
        break;
    }
}



