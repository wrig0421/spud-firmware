#include "packet_def.h"
#include "gt_521fx_driver.h"
#include "cmsis_os.h"
#include "packet_queue.h"
#include "queue.h"


#define RX_QUEUE_DEPTH  16 // pkts
#define TX_QUEUE_DEPTH  16 // pkts


typedef StaticTask_t osStaticThreadDef_t;
typedef StaticQueue_t osStaticMessageQDef_t;


osMessageQueueId_t rx_queue_handle;
uint8_t rx_queue_buffer[ RX_QUEUE_DEPTH * sizeof( pkt_t ) ];
osStaticMessageQDef_t rx_queue_ctrl;
const osMessageQueueAttr_t rx_queue_atrributes = {
  .name = "sensor_rx_queue",
  .cb_mem = &rx_queue_ctrl,
  .cb_size = sizeof(rx_queue_ctrl),
  .mq_mem = &rx_queue_buffer,
  .mq_size = sizeof(rx_queue_buffer)
};


osMessageQueueId_t tx_queue_handle;
uint8_t tx_queue_buffer[ TX_QUEUE_DEPTH * sizeof( pkt_t ) ];
osStaticMessageQDef_t tx_queue_ctrl;
const osMessageQueueAttr_t tx_queue_attributes = {
  .name = "sensor_tx_queue",
  .cb_mem = &tx_queue_ctrl,
  .cb_size = sizeof(tx_queue_ctrl),
  .mq_mem = &tx_queue_buffer,
  .mq_size = sizeof(tx_queue_buffer)
};


#if 0
osMessageQueueId_t rx_queue_handle;
const osMessageQueueAttr_t rx_queue_atrributes = {
  .name = "sensor_rx_queue"
};
/* Definitions for sensor_tx_queue */
osMessageQueueId_t tx_queue_handle;
const osMessageQueueAttr_t tx_queue_attributes = {
  .name = "sensor_tx_queue"
};
#endif

void packet_rsp_set(void);


void packet_queue_init(void)
{
    rx_queue_handle = osMessageQueueNew (RX_QUEUE_DEPTH, sizeof( pkt_t ), &rx_queue_atrributes);
    tx_queue_handle = osMessageQueueNew (TX_QUEUE_DEPTH, sizeof( pkt_t ), &tx_queue_attributes);
}

void packet_enqueue(p_packet_handle_t pkt_handle, pkt_src_dst_t dst)
{
	// todo add blocking w/ parameter
	switch (dst)
	{
		case PKT_SRC_DST_HOST_TX:
			if (osOK != osMessageQueuePut(tx_queue_handle, pkt_handle, 0, 0))
			{
				while(1); // queue full?
			}
		break;
		case PKT_SRC_DST_HOST_RX:
			if (osOK != osMessageQueuePut(rx_queue_handle, pkt_handle, 0, 0))
			{
				while(1); // queue full?
			}
		break;
		default:
			while(1); // wtf
		break;
	}
}


void packet_dequeue(p_packet_handle_t pkt_handle, pkt_src_dst_t src)
{
	switch(src)
	{
		case PKT_SRC_DST_HOST_TX:
			if (osOK != osMessageQueueGet(tx_queue_handle, (uint8_t *)pkt_handle, NULL, osWaitForever))
			{
				while(1); // wtf
			}
			//packet_rsp_set();
		break;
		case PKT_SRC_DST_HOST_RX:
			if (osOK != osMessageQueueGet(rx_queue_handle, pkt_handle, NULL, osWaitForever))
			{
				while(1); // wtf
			}
			//packet_rsp_set();
		break;
		default:
		break;
	}
}


void packet_enqueue_to_sensor_tx(p_packet_handle_t pkt_handle)
{
	packet_enqueue(pkt_handle, PKT_SRC_DST_HOST_TX);
}


void packet_dequeue_from_sensor_tx(p_packet_handle_t pkt_handle)
{
	packet_dequeue(pkt_handle, PKT_SRC_DST_HOST_TX);
}


void packet_enqueue_to_sensor_rx(p_packet_handle_t pkt_handle)
{
	packet_enqueue(pkt_handle, PKT_SRC_DST_HOST_RX);
}


void packet_dequeue_from_sensor_rx(p_packet_handle_t pkt_handle)
{
	packet_dequeue(pkt_handle, PKT_SRC_DST_HOST_RX);
}


void packet_parse_rsp(p_packet_handle_t pkt_handle)
{

}


bool packet_rsp_received = false;

void packet_rsp_clear(void)
{
	packet_rsp_received = false;
}


void packet_rsp_set(void)
{
	packet_rsp_received = true;
}


bool packet_rsp_was_received(void)
{
	if (packet_rsp_received)
	{
		packet_rsp_received = false;
		return true;
	}
	else
	{
		return false;
	}
}


void packet_create_cmd_and_send(p_packet_handle_t pkt_handle, gt_521fx_cmd_e cmd, uint32_t input_param)
{
	packet_rsp_clear();
	g_cmd_in_flight = cmd;
	pkt_handle->start_code[0] = 0x55; // default
	pkt_handle->start_code[1] = 0xAA; // default
	pkt_handle->dev_id = 0x0001; // default
	pkt_handle->cmd_input_param = input_param;
	pkt_handle->cmd_code = cmd;
	pkt_handle->check_sum = packet_calc_check_sum(pkt_handle);
	packet_enqueue_to_sensor_tx(pkt_handle);
}



