
#include "FreeRTOS.h"
#include "cmsis_os2.h"
#include "pkt.h"


typedef enum
{
    PKT_SRC_DST_HOST_RX = 0,
    PKT_SRC_DST_HOST_TX
} pkt_src_dst_e;


#define RX_QUEUE_DEPTH  16 // pkts
#define TX_QUEUE_DEPTH  16 // pkts


typedef StaticTask_t osStaticThreadDef_t;
typedef StaticQueue_t osStaticMessageQDef_t;


osMessageQueueId_t gp_rx_queue;
uint8_t g_rx_queue_buffer[RX_QUEUE_DEPTH * sizeof(pkt_t)];
osStaticMessageQDef_t g_rx_queue_ctrl;
const osMessageQueueAttr_t g_rx_queue_attributes =
{
    .name = "rx_queue",
    .cb_mem = &g_rx_queue_ctrl,
    .cb_size = sizeof(g_rx_queue_ctrl),
    .mq_mem = &g_rx_queue_buffer,
    .mq_size = sizeof(g_rx_queue_buffer)
};


osMessageQueueId_t gp_tx_queue;
uint8_t g_tx_queue_buffer[TX_QUEUE_DEPTH * sizeof(pkt_t)];
osStaticMessageQDef_t g_tx_queue_ctrl;
const osMessageQueueAttr_t g_tx_queue_attributes = {
    .name = "tx_queue",
    .cb_mem = &g_tx_queue_ctrl,
    .cb_size = sizeof(g_tx_queue_ctrl),
    .mq_mem = &g_tx_queue_buffer,
    .mq_size = sizeof(g_tx_queue_buffer)
};


void packet_rsp_set(void);


void packet_queue_init(void)
{
    gp_rx_queue = osMessageQueueNew(RX_QUEUE_DEPTH, sizeof(pkt_t), &g_rx_queue_attributes);
    gp_tx_queue = osMessageQueueNew(TX_QUEUE_DEPTH, sizeof(pkt_t), &g_tx_queue_attributes);
}


void pkt_enqueue(p_pkt_t pkt_handle)
{
    pkt_src_e pkt_src = pkt_handle->header.src;
    switch (pkt_src)
    {
        case PKT_SRC_PCB:
            if (osOK != osMessageQueuePut(gp_tx_queue, pkt_handle, 0, 0)) while(1); // queue full?
        break;
        case PKT_SRC_COMP:
            if (osOK != osMessageQueuePut(gp_rx_queue, pkt_handle, 0, 0)) while(1); // queue full?
        break;
        default:
            while(1); // this is an error... trap it
        break;
    }
}


void pkt_dequeue(p_pkt_t pkt_handle)
{
    pkt_src_e pkt_src = pkt_handle->header.src;
    switch(pkt_src)
    {
        case PKT_SRC_PCB:
            if (osOK != osMessageQueueGet(gp_tx_queue, (uint8_t *)pkt_handle, NULL, osWaitForever)) while(1); // queue full?
        break;
        case PKT_SRC_COMP:
            if (osOK != osMessageQueueGet(gp_rx_queue, pkt_handle, NULL, osWaitForever)) while(1);  // queue full?
        break;
        default:
            while(1); // this is an error... trap it
        break;
    }
}



bool packet_rsp_received = false;

void packet_rsp_clear(void)
{
    packet_rsp_received = false;
}


void packet_rsp_set(void)
{
    packet_rsp_received = true;
}


bool packet_rsp_was_received(void)
{
    if (packet_rsp_received)
    {
        packet_rsp_received = false;
        return true;
    }
    else
    {
        return false;
    }
}


void packet_parse(p_packet_handle_t pkt_handle)
{
    pkt_id_e pkt_id;
    pkt_id = (pkt_id_e)(pkt_handle->header.tag);

    switch (pkt_id)
    {
        case PKT_ID_CMD:

        break;
        default:
        break;
    }
}
