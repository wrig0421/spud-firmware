// SRW
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>

#include "main.h"
#include "cmsis_os.h"
#include "FreeRTOS.h"
#include "task.h"

#include "board_init_common.h"
#include "board_specific.h"
#include "cmsis_os.h"
#include "task_led_ctrl.h"
#include "task_button_press.h"

#define TASK_BUTTON_PRESS_ITERATION_TIME_MILLISECONDS   10
#define TASK_BUTTON_PRESS_STATE_TRANSITION_TIME_MILLISECONDS     3000

bool g_animate_led_pause_flag = false;
bool g_animate_led_interrupt = false;
bool g_interrupt_flag[NUM_ISR] = {false};

bool task_button_press_interrupt_occurred(void)
{
    return g_animate_led_interrupt;
}


isr_e task_led_ctrl_button_to_isr(board_init_push_buttons_e button)
{
    isr_e return_val;
    switch (button)
    {
        case PUSH_BUTTON_A:
            return_val = ISR_SPEED;
        break;
        case PUSH_BUTTON_B:
            return_val = ISR_STATE;
        break;
        case PUSH_BUTTON_C:
            return_val = ISR_COLOR;
        break;
        case PUSH_BUTTON_D:
            return_val = ISR_PAUSE;
        break;
        default: // do nothing!
        break;
    }
    return return_val;
}


void task_button_press_ctrl_set_interrupt_flag(isr_e src)
{
    g_animate_led_interrupt = true;
    g_interrupt_flag[src] = true;
}


bool task_button_press_ctrl_interrupt_flag(isr_e src)
{
    bool return_val = g_interrupt_flag[src];
    if (return_val) g_interrupt_flag[src] = false; // auto clear
    return return_val;
}


bool task_button_press_check_interrupts(uint8_t *red, uint8_t *green, uint8_t *blue)
{
    bool return_val = false;
    if (task_button_press_ctrl_interrupt_flag(ISR_STATE))
    {
        task_button_press_interrupt_flag_clear();
        return_val = true;
        animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLACK);
    }
    else if (task_button_press_ctrl_interrupt_flag(ISR_PAUSE))
    {
        task_button_press_interrupt_flag_clear();
        while (g_animate_led_pause_flag)
        {
            osDelay(10);
        }
    }
    else if (task_button_press_ctrl_interrupt_flag(ISR_COLOR))
    {
        task_button_press_interrupt_flag_clear();
        // interrupt modifies the current color... apply it to the animation!
        *red = task_led_ctrl_cur_color_red_hex();
        *green = task_led_ctrl_cur_color_green_hex();
        *blue = task_led_ctrl_cur_color_blue_hex();
    }
    return return_val;
}


void task_button_press_interrupt_flag_clear(void)
{
    g_animate_led_interrupt = false;
}


void task_button_press(void *argument)
{
    uint32_t dummy = 0;
    uint32_t button_debounce_count = 0;
    bool repeat_flag = true;
    while (1)
    {
        // TODO add a task block here waiting for execution!
        // This task will only be executed when a button press occurs
        // wait on flag to unblock..
        xTaskNotifyWait(0, 0, &dummy, portMAX_DELAY);

        for (board_init_push_buttons_e button = 0; button < NUM_PUSH_BUTTONS; button = (board_init_push_buttons_e)(button + 1))
        {
            if(board_init_button_is_pressed(button))
            {
                // clear current button count
                board_init_button_on_count_clear(button);
                repeat_flag = true;
                // wait for user to release the button
                while (repeat_flag)
                {
                    while (board_init_button_is_pressed(button))
                    {
                        board_init_button_on_count_increment(button);
                        osDelay(TASK_BUTTON_PRESS_ITERATION_TIME_MILLISECONDS);

                    }
                    while (button_debounce_count++ < 10)
                    {
                        osDelay(10);
                        if (board_init_button_is_pressed(button))
                        {
                            repeat_flag = true;
                            break;
                        }
                    }
                }
                // button is released here!
                if ((TASK_BUTTON_PRESS_STATE_TRANSITION_TIME_MILLISECONDS / TASK_BUTTON_PRESS_ITERATION_TIME_MILLISECONDS) < (board_init_button_on_count(button)))
                {
                    board_init_button_on_count_clear(button);
                    switch (button)
                    {
                        case PUSH_BUTTON_A:
                            task_led_ctrl_set_default_speed();
                            //HAL_NVIC_SetPriority(EXTI0_IRQn, 24, 0);
                            //HAL_NVIC_EnableIRQ(EXTI0_IRQn);
                        break;

                        case PUSH_BUTTON_B:
                            // signal to the user that color state is changing
                            for (uint8_t iii = 0; iii < 3; iii++)
                            {
                                animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_RED);
                                osDelay(100);
                                animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLACK);
                                osDelay(100);
                            }
                            task_led_ctrl_reset_animate_iteration_count();
                            task_led_ctrl_enter_animation_demo_state(); // enter demo state
                        break;

                        case PUSH_BUTTON_C:
                            // signal to the user that color state is changing
                            for (uint8_t iii = 0; iii < 3; iii++)
                            {
                                animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLUE);
                                osDelay(100);
                                animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLACK);
                                osDelay(100);
                            }
                            // don't change iteration count.  Simply go to color demo mode.
                            task_led_ctrl_enter_color_demo_state();
                        break;

                        case PUSH_BUTTON_D:
                            // future
                        break;

                        default:
                        break;
                    }
                }
                else
                {
                    // set ISR flag
                    task_button_press_ctrl_set_interrupt_flag(task_led_ctrl_button_to_isr(button));
                    switch (button)
                    {
                        case PUSH_BUTTON_A:
                            task_led_ctrl_adjust_speed();
                            //HAL_NVIC_SetPriority(EXTI0_IRQn, 24, 0);
                            //HAL_NVIC_EnableIRQ(EXTI0_IRQn);
                        break;
                        case PUSH_BUTTON_B:
                            // exit demo state if in it.
                            if (MASTER_LED_STATE_DEMO == task_led_ctrl_master_state())
                            {
                                task_led_ctrl_exit_animation_demo_state(); // animation count is auto cleared here.
                            }
                            else
                            {
                                task_led_ctrl_reset_animate_iteration_count();
                                task_led_ctrl_adjust_state();
                            }
                        break;
                        case PUSH_BUTTON_C:
                            // exit demo state if in it.
                            if (MASTER_COLOR_STATE_DEMO == task_led_ctrl_cur_state())
                            {
                                task_led_ctrl_exit_color_demo_state();
                            }
                            else
                            {
                                task_led_ctrl_adjust_color();
                            }
                        break;
                        case PUSH_BUTTON_D:
                            task_led_ctrl_pause();
                        break;
                        default:
                        break;
                    }
                }
            }
        }
    }

}
