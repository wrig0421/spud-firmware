// SRW
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <math.h>
#include "main.h"
#include "cmsis_os.h"
#include "numbers.h"
#include "color_led.h"
#include "ws2812b.h"
#include "board_specific.h"
#include "board_init_common.h"
#include "animate_led.h"


#define TEST_MODE
static void handle_count_color_delay(const animation_loop_iterations_e max_iterations, const animation_delay_ms_e animation_delay_ms)
{
    if (ANIMATION_DELAY_MS_0 != animation_delay_ms) delay(animation_delay_ms);
    g_animation_iterations++;
    if (MASTER_LED_STATE_DEMO == g_master_led_state)
    {
        if (max_iterations == g_animation_iterations)
        {
#if defined(TEST_MODE)
            g_led_state = (led_state_e) (g_led_state + 1);
            if (NUM_LED_STATES == g_led_state) g_led_state = LED_STATE_FIRST;
#else
            g_led_state = animate_led_state_randomize(g_led_state);
#endif
            g_animation_iterations = 0;
        }
    }
    if (MASTER_COLOR_STATE_DEMO == g_master_color_state) color_led_randomize();
    //else color_led_adjust_color();
    // if not demo state then stay in current LED state forever until switched by user
}


void task_animate_led(void *argument)
{
    uint32_t button_pressed_count = 0;
    board_init_stop_timer();
    animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLACK);
    osDelay(1000);
    bool button_press_b_detected = false;
    bool button_press_c_detected = false;
    while (1)
    {
        if (!button_press_c_detected && board_init_button_is_pressed(PUSH_BUTTON_C))
        {
            button_press_c_detected = true;
        }
        else if (button_press_c_detected && board_init_button_is_pressed(PUSH_BUTTON_C))
        {
            button_press_c_detected = false;
            while (board_init_button_is_pressed(PUSH_BUTTON_C))
            {
                if ((board_init_button_on_count(PUSH_BUTTON_C) > button_pressed_count) && \
                                board_init_button_on_count(PUSH_BUTTON_C) > 50)
                {
                    // the button is being held down!
                    color_led_enter_demo_state();
                    while(board_init_button_is_pressed(PUSH_BUTTON_C)); // wait for release
                    // clear the counts..
                    board_init_button_on_count_clear(PUSH_BUTTON_C);
                    for (uint8_t iii = 0; iii < 3; iii++)
                    {
                        animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLUE);
                        osDelay(100);
                        animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLACK);
                        osDelay(100);
                    }
                    osDelay(500);
                    break;
                }
                else if (!board_init_button_on_count(PUSH_BUTTON_C))
                {
                    break;
                }
            }
        }
        if (!button_press_b_detected && board_init_button_is_pressed(PUSH_BUTTON_B))
        {
            button_press_b_detected = true;
        }
        else if (button_press_c_detected && board_init_button_is_pressed(PUSH_BUTTON_C))
        {
            button_press_b_detected = false;
            while (board_init_button_is_pressed(PUSH_BUTTON_B))
            {
                if ((board_init_button_on_count(PUSH_BUTTON_B) > button_pressed_count) && \
                                board_init_button_on_count(PUSH_BUTTON_B) > 50)
                {
                    // the button is being held down!
                    animate_led_enter_demo_state();
                    while(board_init_button_is_pressed(PUSH_BUTTON_B)); // wait for release
                    // clear the counts..
                    board_init_button_on_count_clear(PUSH_BUTTON_B);
                    for (uint8_t iii = 0; iii < 3; iii++)
                    {
                        animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLUE);
                        osDelay(100);
                        animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_BLACK);
                        osDelay(100);
                    }
                    osDelay(500);
                    break;
                }
                else if (!board_init_button_on_count(PUSH_BUTTON_B))
                {
                    break;
                }
            }
        }
        switch(g_led_state)
        {
            case LED_STATE_WHITE_COLOR:
                animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, COLOR_HEX_WHITE);
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_1, ANIMATION_DELAY_MS_5000);
            break;
            case LED_STATE_SOLID_COLOR:
                animate_led_solid_custom_color((uint16_t)STRIP_BIT_ALL_SET, color_led_cur_color_hex());
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_5, ANIMATION_DELAY_MS_5000);
            break;
            case LED_STATE_SPARKLE_NO_FILL:
                // SRW OK!!!
                // need to force all colors off before transitioning to this state
                animate_led_turn_all_pixels_off();
                animate_led_sparkle_only_random_color(STRIP_BIT_ALL_SET, false, random_num(20,80));//random(0, 50));
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_5, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_SPARKLE_FILL:
                // SRW ok!!!
                animate_led_sparkle_only_random_color(STRIP_BIT_ALL_SET, true, random_num(20,80));
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_10, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_RAINBOW_CYCLE:
                // SRW OK!!!
                animate_led_rainbow_cycle(STRIP_BIT_ALL_SET, 0);
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_5, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_THEATER_CHASE:
                // SRW ok !!!
                animate_led_theater_chase(STRIP_BIT_ALL_SET, color_led_cur_color_hex(), animate_led_delay_in_animations());
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_10, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_THEATER_CHASE_RAINBOW:
                // SRW ok!!!!
                animate_led_theater_chase_rainbow(STRIP_BIT_ALL_SET, animate_led_delay_in_animations());
                g_led_state = LED_STATE_TWINKLE;
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_2, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_FADE_IN_AND_OUT:
                // SRW ok!!!
                animate_led_fade_in_fade_out((uint16_t)STRIP_BIT_ALL_SET, color_led_cur_color_hex());
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_10, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_TWINKLE:
                // SRW ok!!!
                animate_led_turn_all_pixels_off();
                animate_led_twinkle(STRIP_BIT_ALL_SET, color_led_cur_color_hex(), (uint32_t)((float)NUM_LEDS * (float)0.9), animate_led_delay_in_animations(), false);
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_5, ANIMATION_DELAY_MS_0);
            break;
            case LED_STATE_SPELL:
                // SRW ok!!!
                animate_led_only_spell_word(STRIP_BIT_ALL_SET, color_led_cur_color_hex(), 30);
                handle_count_color_delay(ANIMATION_LOOP_ITERATIONS_10, ANIMATION_DELAY_MS_0);
            break;
            default:
            break;
        }
    }
}
